#!/usr/bin/python

from __future__ import division

import sys
import PyTango
import RPi.GPIO as GPIO
from time import sleep

Reps = 400                  # 2000 Hz cycle time, so Reps=400 is 0.2s for each percentage ON
Hertz = 2000                # Cycle time. You can tweak this, Max 3000
Freq = (1 / float(Hertz)) - 0.0003           # run_motor loop code takes 0.0003s

class PyDevice(PyTango.DeviceClass):
    cmd_list = {'start': [[PyTango.ArgType.DevVoid],
                          [PyTango.ArgType.DevVoid]],
                'stop': [[PyTango.ArgType.DevVoid],
                         [PyTango.ArgType.DevVoid]],
                'move': [[PyTango.ArgType.DevVarFloatArray],
                          [PyTango.ArgType.DevVoid]],}
    attr_type = [
        [PyTango.ArgType.DevFloat,
         PyTango.AttrDataFormat.SCALAR,
         PyTango.AttrWriteType.READ],
        {'polling period': 400}
    ]
    attr_list = {
        'translate_speed': attr_type,
        'rotate_speed': attr_type,
    }

    def __init__(self, name):
        PyTango.DeviceClass.__init__(self, name)
        self.set_type("TestDevice")


class PyTrevor(PyTango.Device_4Impl):
    def __init__(self, cl, name):
        self.devices = {}
        PyTango.Device_4Impl.__init__(self, cl, name)
        self.info_stream('In PyTrevor.__init__')
        PyTrevor.init_device(self)

    def __del__(self):
        print ("destructor")
	# switch MotorB/A off
	GPIO.output (19, 1)
	GPIO.output (24, 1)
	GPIO.output (21, 0)
	GPIO.output (26, 0)
	GPIO.cleanup()              # reset all ports
	
    def start(self):
        print 'start'

    def stop(self):
	# switch MotorB and MotorA \off
	GPIO.output (19, 1)
	GPIO.output (24, 1)
	GPIO.output (21, 0)
	GPIO.output (26, 0)
        print 'stop'
        

    def move(self, speed):
        self.translate_speed = float(speed[0])
        self.rotate_speed = float(speed[1])
        print 'move with translate_speed and rotate_speed values:', self.translate_speed, self.rotate_speed
	pulse_width = translate_speed * Freq           # define exact pulse width
        time_period = Freq - (Freq * translate_speed)  # sleep period needed to get required Hz
        run_motor(Reps, pulse_width, 21, 24, time_period)

    def init_device(self):
        self.info_stream('In Python init_device method')
        self.translate_speed = 0
        self.rotate_speed = 0
        self.set_state(PyTango.DevState.ON)
	#GPIO specific initializations
	GPIO.cleanup()
	GPIO.setwarnings(False)
	GPIO.setmode(GPIO.BOARD)
	GPIO.setup(19, GPIO.OUT)
	GPIO.setup(21, GPIO.OUT)
	GPIO.setup(24, GPIO.OUT)
	GPIO.setup(26, GPIO.OUT)
	# switch MotorB and MotorA \off
	GPIO.output (19, 1)
	GPIO.output (24, 1)
	GPIO.output (21, 0)
	GPIO.output (26, 0)




if __name__ == '__main__':
    util = PyTango.Util(sys.argv)
    util.add_class(PyDevice, PyTrevor)

    U = PyTango.Util.instance()
    U.server_init()
    U.server_run()

def run_motor(Reps, pulse_width, port_numA, port_numB, time_period):
    try:                                     # try: except:, traps errors
        for i in range(0, Reps):
            GPIO.output(port_numA, 1)      # switch port on
            GPIO.output(port_numB, 0)      # switch port on
            sleep(pulse_width)               # make sure pulse stays on for correct time
            GPIO.output(port_numA, 0)     # switch port off
            GPIO.output(port_numB, 1)     # switch port off
            sleep(time_period)               # time_period for port OFF defined in run_loop
    except KeyboardInterrupt:                # reset all ports used by this program if CTRL-C pressed
        GPIO.cleanup()

